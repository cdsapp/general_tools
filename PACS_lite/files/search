cd ..
cp files/search_pre.txt corpus/search_pre.tmp
cp files/search_post.txt corpus/search_post.tmp
cp files/query.txt corpus/cs.q
cp files/colors.list corpus/colors.list

cd corpus

CS="CS_2.003.04.jar"



echo "Starting log" > log.tmp
date >> log.tmp

sed '1s/^/\n\n/' cs.q > cs.1.q
mv -f cs.1.q cs.q

sed '1s/^/copy_corpus: f/' cs.q > cs.1.q
mv -f cs.1.q cs.q

sed '1s/^/\n/' cs.q > cs.1.q
mv -f cs.1.q cs.q

if ! grep -q "^node:" "cs.q"; then
	sed '1s/^/node: $ROOT/' cs.q > cs.1.q
	mv -f cs.1.q cs.q
fi

# This finds the largest {number}
largest=$(grep -o '{[0-9]*}' cs.q| sed 's/[{}]//g' | sort -n | tail -n 1)

PL='add_leaf_before{'
PM='}: (CODE <span class="pos" style="color:'
PR=';">)'
AL='add_leaf_after{'
AR='}: (CODE </span>)'

echo "searching for {number}"
echo "$largest is largest" >> log.tmp

cat cs.q
echo ""
cat cs.q >> log.tmp
echo "" >> log.tmp

if grep -q '{[0-9]}' cs.q; then
	echo "largest number is $largest"
	echo "" >> cs.q
	echo "" >> cs.q
	for ((i=$largest; i>=1; i--)); do
		if [ "$i" -gt 9 ]; then
			color="red"
		else
			color=$(sed -n "${i}p" colors.list | tr -d '\n')
		fi
		LEAF="leaf"
		checkleaf=$i$LEAF
		echo "$checkleaf is being checked for leaf" >> log.tmp
		if grep -q $checkleaf cs.q; then
			sed "s/$checkleaf//g" cs.q > cs.q.tmp
			mv -f cs.q.tmp cs.q
			TPL='prepend_label{'
			TPM='}: <font color="'
			TPR='">'
			TAL='append_label{'
			TAR='}: </font>'
			PA=$TPL$i$TPM$color$TPR
			AA=$TAL$i$TAR
		else
			PA=$PL$i$PM$color$PR
			AA=$AL$i$AR
		fi
		echo $AA >> cs.q
		echo $PA >> cs.q
	done
fi

echo "~~~running query"
echo "~~~running query" >> log.tmp
date >> log.tmp
# Now run the .q query

rm -f ERR
rm -f cs.out
# Change *.txt to *.psd in the line:
java -classpath /Applications/CS_2.003.04.jar csearch/CorpusSearch cs.q *.txt 2> ERR
if grep -q "ERROR" ERR; then
	cd ..
	cp corpus/ERR files/cs.html
	cp corpus/log.tmp files/log.tmp
	rm -f corpus/search_pre.tmp
	rm -f corpus/search_post.tmp
	rm -f corpus/log.tmp
	rm -f corpus/ERR
	rm -f corpus/cs.q
	rm -f corpus/colors.list
	cd files
else # This starts a giant else block.

cd ..
cp corpus/cs.out files/cs.out
cp corpus/log.tmp files/log.tmp
cp corpus/cs.q files/query.txt
rm -f corpus/search_pre.tmp
rm -f corpus/search_post.tmp
rm -f corpus/log.tmp
rm -f corpus/ERR
rm -f corpus/cs.q
rm -f corpus/cs.out
rm -f corpus/colors.list
cd files
cp cs.out cs.out.tmp
echo "done" >> log.tmp
date >> log.tmp
# Make list of hits in cs.out to append to cs.html
cp cs.out cs.list

tr -d '\n' < cs.list > cs.list.1
mv -f cs.list.1 cs.list
#*~//*
sed 's#*~//*#*~/ADDNEWLINEHERE/*#g' cs.list > cs.list.1
mv -f cs.list.1 cs.list

sed 's/ADDNEWLINEHERE/\n/g' cs.list > cs.list.1
mv -f cs.list.1 cs.list
#*/(
sed 's#*/(#*/\n(#g' cs.list > cs.list.1
mv -f cs.list.1 cs.list

sed '/^\/\*\*/!d' cs.list > cs.list.1
mv -f cs.list.1 cs.list

sed 's/  /~/g' cs.list > cs.list.1
mv -f cs.list.1 cs.list

sed 's/**[^~]*~//g' cs.list > cs.list.1
mv -f cs.list.1 cs.list

sed 's/ /	/' cs.list > cs.list.1
mv -f cs.list.1 cs.list



sed 's/SUMMARY:/PLACEHOLDER/' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

echo "SUMMARY:" >> cs.list

sed '/PLACEHOLDER/r cs.list' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/PLACEHOLDER//' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

# Highlight hits in the summary

sed 's#1/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#2/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#3/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#4/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#5/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#6/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#7/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#8/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#9/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#10/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#20/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#30/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#40/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#50/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#60/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#70/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#80/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#90/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's#100/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#200/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#300/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#400/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#500/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#600/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#700/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#800/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed 's#900/#ħɪɠħɭɪɠħʈ&#g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed '/ħɪɠħɭɪɠħʈ/ s/^/<mark>/' cs.out > cs.out.1
mv -f cs.out.1 cs.out	

sed '/ħɪɠħɭɪɠħʈ/ s/$/<\/mark>/' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/ħɪɠħɭɪɠħʈ//g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed '/prepend_label/ s/$/<\/font>/' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed '/add_leaf_before/ s/$/<\/span>/' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/(CODE (CODE/(CODE/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out


sed 's/(CODE <span/<span/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/(CODE <\/span>)/<\/span>/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/">)/">/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/^[[:space:]]*\(<\/span\)/\1/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

awk '
    NR==1 { prev=$0; next }

    /^<\/span/ {
        prev = prev $0;     # attach this line to the previous one
        next
    }

    {
        print prev;         # output the completed previous line
        prev = $0;          # begin new buffer
    }

    END { print prev }
' cs.out > cs.out.1
mv -f cs.out.1 cs.out

awk '/<span/ {printf $0, "%s"; next} {print}' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/;">[[:space:]]*(/;"> (/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

sed 's/"> (/">(/g' cs.out > cs.out.1
mv -f cs.out.1 cs.out

echo "converting cs.out to cs.html" >> log.tmp
# And convert cs.out into cs.html
mv -f cs.out cs.html

sed 's/<s>/(s)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<u>/(u)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<i>/(i)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<eN>/(eN)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<N>/(N)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<unknown>/(unknown)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<em>/(em)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<m>/(m)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<e>/(e)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html

sed 's/<S>/(S)/g' cs.html > cs.1.html
mv -f cs.1.html cs.html


sed '1s/^/<pre> /' cs.html > cs.1.html
mv -f cs.1.html cs.html

cp cs.html cs.1.html
cp search_pre.tmp search_pre.1.txt

cat cs.1.html >> search_pre.1.txt
mv -f search_pre.1.txt cs.html
rm cs.1.html

echo '</pre>' >> cs.html
cat search_post.tmp >> cs.html
echo "pre-tag added to cs.html" >> log.tmp
fi # Here's the end of the giant 'else' block.
echo "~~~query completed!"
echo "Query completed" >> log.tmp

open -a "Google Chrome" PACS_lite.html